{
  "nodes": [
    {
      "id": "198218389874da05",
      "type": "group",
      "styleAttributes": {
        "border": "dashed"
      },
      "x": -460,
      "y": -260,
      "width": 2500,
      "height": 1720,
      "color": "4",
      "label": "Графы"
    },
    {
      "id": "fe8caee8c34c0eff",
      "type": "text",
      "text": "#Прима\n1. Создаём список:\n    1. Ключей, который изначально для каждой вершины равен $∞$, кроме стартовой вершины, у которой ключ равен $0$.\n    2. Список включённых в $MST$ вершин (по сути список из 0)\n    3. Список $parent$, который изначально для каждой вершины равен $-1$\n2. Берём вершину $u$, которая не включена в $MST$, такую, что $keys(u)$  минимальна\n3. Перебираем смежные с ней вершины $v$ и  $w$ вес ребра $u,v$ \n4. Если $keys(v) > w$, то $keys(v) = w$ и $parent(v) = u$\n5. Повторяем с шага 2, пока все вершины не добавлены в $MST$",
      "styleAttributes": {},
      "x": 1140,
      "y": -220,
      "width": 740,
      "height": 360
    },
    {
      "id": "dafa1ddee9d5264c",
      "type": "text",
      "text": "#Краскала\n1. Сортируем рёбра в порядке возрастания их весов.\n2. Создаём список $parent$ (представителей), где изначально каждая вершина является представителем самой себя. Также создаём список $rank$, изначально ранг каждой вершины равен 1.\n3. Берём ребро из отсортированного списка $(u, v, w)$. \n4. Ищем представителей у $u$ и $v$.\n    1. Если представитель один и тот же, то переходим к шагу 3, пропуская это ребро\n    2. Если представители разные, выполняем объединение (шаг 5)\n5. Объединение: \n    1. $rank(u) > rank(v)$, тогда $parent(v) = u$ \n    2. $rank(u) < rank(v)$, тогда $parent(u) = v$\n    3. $rank(u) = rank(v)$, тогда $parent(v) = u$ и $rank(u) += 1$\n6. Если в некий список рёбер было добавлено $V-1$ ребро, где $V$ - количество вершин, то выходим из цикла",
      "styleAttributes": {},
      "x": 1140,
      "y": 200,
      "width": 740,
      "height": 540
    },
    {
      "id": "d787f403d9f5df1a",
      "type": "text",
      "text": "#Форда-Фалкерсона (улучшенный Эдмондса-Карпа)\n1. $maxFlow = 0$\n2. Ищем путь от вершины $s$ - истока к вершине $t$ - сток с помощью BFS. \n3. На найденном пути находим минимальную пропускную способность $c_{min}$\n4. Для каждого ребра $(u, v)$ этого пути уменьшаем пропускную способность на $c_{min}$, а для обратного ребра $(v, u)$ увеличиваем пропускную способность на $c_{min}$\n5. $maxFlow += c_{min}$\n6. Возвращаемся на шаг 2, если ещё есть пути от $s$ к $t$\n7. Результат: $maxFlow$",
      "styleAttributes": {},
      "x": 1140,
      "y": 780,
      "width": 740,
      "height": 314
    },
    {
      "id": "2a7126f35a501b45",
      "type": "text",
      "text": "#Беллмана-Форда\n1. Инициализация: всем вершинам присваивается предполагаемое расстояние $dist[v]=∞$, кроме вершины-источника, для которой $dist(u)=0$.\n2. Релаксация множества рёбер $E$\n    1. Для каждого ребра $e=(v,z)∈E$ вычисляется новое предполагаемое расстояние $new_dist(z)=dist(v)+w(e)$.\n    2. Если $new_dist(z)<dist(z)$, то происходит присваивание $dist(z)=new_dist(z)$ (релаксация ребра $e$).\n3. Алгоритм производит релаксацию всех рёбер графа до тех пор, пока на очередной итерации происходит релаксация хотя бы одного ребра.\n4. **Критерий наличия достижимого цикла отрицательного веса**: если после $n-1$ фазы мы выполним ещё одну фазу, и на ней произойдёт хотя бы одна релаксация, то граф содержит цикл отрицательного веса, достижимый из $v$; в противном случае, такого цикла нет.",
      "styleAttributes": {},
      "x": -420,
      "y": 884,
      "width": 680,
      "height": 420
    },
    {
      "id": "db2fed752149b8ef",
      "type": "text",
      "text": "#DFS\n1. Выбираем любую вершину из еще не пройденных, обозначим ее как $u$\n2. Запускаем процедуру $dfs(u)$\n     1. Помечаем вершину $u$ как пройденную\n     2. Для каждой не пройденной смежной с $u$ вершиной (назовем ее $v$) запускаем $dfs(v)$\n3. Повторяем шаги 1 и 2, пока все вершины не окажутся пройденными.",
      "styleAttributes": {
        "textAlign": null,
        "border": null
      },
      "x": -420,
      "y": -220,
      "width": 680,
      "height": 276
    },
    {
      "id": "3db0bec6568d80c9",
      "type": "text",
      "text": "#Кана \n1. Создаём список, где указываем для каждой вершины количество входящих рёбер \n2. Если количество входящих рёбер равно 0, добавить в очередь\n3. Взять вершину из очереди и пометить как посещённую\n4. Для всех смежных вершин уменьшить количество входящих рёбер на 1\n5. Добавить в очередь вершину, если количество входящих рёбер равно 0\n6. Пока очередь не пуста снова с шага 3 \n",
      "styleAttributes": {
        "border": null
      },
      "x": 300,
      "y": -220,
      "width": 740,
      "height": 276
    },
    {
      "id": "d68ad71144f9f8a8",
      "type": "text",
      "text": "#Дейкстры\n1. Создать массив $dist$ расстояний. Изначально $dist[s]=0$ и $dist[v]=∞$ для $v≠s$.\n2. Создать булев массив $used$, $used[v]=0$ для всех вершин $v$ — в нём мы будем отмечать, совершалась ли релаксация из вершины.\n3. Пока существует вершина $v$ такая, что $used[v]=0$ и $dist[v]≠∞$, притом, если таких вершин несколько, то $v$ — вершина с минимальным $dist[v]$, делать следующее:\n    1. Пометить, что мы совершали релаксацию из вершины $v$, то есть присвоить $used[v]=1$.\n    2. Рассматриваем все рёбра $(v,u)∈E$. Для каждого ребра пытаемся сделать релаксацию: если $dist[v]+w(v,u)<dist[u]$, присвоить $dist[u]=dist[v]+w(v,u)$.",
      "styleAttributes": {},
      "x": 300,
      "y": 80,
      "width": 740,
      "height": 320
    },
    {
      "id": "a55ca236bd51926b",
      "type": "text",
      "text": "#Флойда-Уоршелла\n1. Создаём матрицу кратчайших расстояний между всеми вершинами $dist$\n2. Перебираем все вершины в трёх вложенных циклах $k, i, j$ соответствено\n3. $dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])$ - Если расстояние от $i$ до $j$ через вершину $k$ меньше чем расстояние в матрице, то заменяем",
      "styleAttributes": {},
      "x": 300,
      "y": 440,
      "width": 740,
      "height": 180
    },
    {
      "id": "1341fbfd2e9b586e",
      "type": "text",
      "text": "#BFS\n1. Создадим массив $dist$ расстояний. Изначально $dist[s]=0$ (поскольку расстояний от вершины до самой себя равно $0$) и $dist[v]=∞$ для $v≠s$.\n2. Создадим очередь $q$. Изначально в $q$ добавим вершину $s$.\n3. Пока очередь $q$ не пуста, делаем следующее:\n    1. Извлекаем вершину $v$ из очереди.\n    2. Рассматриваем все рёбра $(v,u)∈E$, то есть те, которые выходят из вершины $v$ Для каждого такого ребра пытаемся сделать релаксацию: если $dist[v]+1<dist[u]$, то мы делаем присвоение $dist[u]=dist[v]+1$ и добавляем вершину $u$ в очередь.",
      "styleAttributes": {},
      "x": -420,
      "y": 530,
      "width": 680,
      "height": 320
    },
    {
      "id": "c3364578f1554f53",
      "type": "text",
      "text": "```python\ndef dfs(u):\n    visited[u] = 1\n    for v in graph[u]:\n        if not visited[v]:\n            dfs(v)\n```",
      "styleAttributes": {
        "border": "dotted"
      },
      "x": -420,
      "y": 120,
      "width": 620,
      "height": 180
    }
  ],
  "edges": [
    {
      "id": "6670bd71e0b68e18",
      "styleAttributes": {},
      "fromNode": "db2fed752149b8ef",
      "fromSide": "bottom",
      "toNode": "c3364578f1554f53",
      "toSide": "top"
    }
  ],
  "metadata": {}
}