# Практика 1
Стандартная библиотека `stdio.h`

**Вывод**
- `printf("")` - Основной способ форматированного вывода в C
- `putchar('')` - Выводит один символ
- `puts("")` - Выводит строку и добавляет `\n`

**Ввод**
- `scanf()` - считывание данных в переменный с форматированием(указывается вручную)
- `getchar()` - читает один символ
- `fgets()` - старый метод считывания 

%% Создать ssh для git %%

# Лекция 1
Принять параметры (`./main 10 -o output`)
```c
int main(int argc, char *argv[]){
    ...
}
```
ИЛИ
```c
int main(int argc, char **argv){
    ...
}
```
- `argc` - количество аргументов
- `argv` - аргументы

`atof` - перевод строки в число

1. Preprocessing (Этап препроцессинга) 
> На этом этапе препроцессор обрабатывает исходный код перед передачей его компилятору. Обрабатываются директивы препроцессора, такие как `#include`, `#define`, `#ifdef`, макросы и другие. В результате исходный код модифицируется, и включаются заголовочные файлы, заменяются макросы и выполняются другие указания. 
2. Compilation (Этап компиляции) 
> Компилятор переводит препроцессированный код на языке высокого уровня (например, C++ или C) в промежуточный объектный код. На этом этапе проверяются синтаксис, типы данных и другие аспекты программы, которые можно проанализировать до выполнения. 
3. Linking (Этап линковки) 
> Объектные файлы, сгенерированные на этапе компиляции, и библиотеки (как статические, так и динамические) объединяются в один исполняемый файл. Линковщик разрешает все внешние зависимости, определяет, где будут размещены функции и данные, и создает исполняемый файл или динамическую библиотеку. 
4. Load-time (Этап загрузки) 
> Операционная система загружает исполняемый файл в память. На этом этапе устанавливается адресное пространство процесса, загружаются динамические библиотеки, инициализируются сегменты кода и данных. 
5. Initialization (Этап инициализации) 
> Во время загрузки и перед началом выполнения основного кода инициализируются глобальные и статические переменные, выполняются конструкторы глобальных объектов (в C++). Эта подготовка необходима для того, чтобы программа могла корректно работать. 
6. Run-time (Этап выполнения)
> Это основной этап, на котором программа выполняет свой код, обрабатывает данные, реагирует на пользовательский ввод и взаимодействует с операционной системой. В этот момент выполняется основной функционал программы. 
7. Runtime Initialization (Инициализация во время выполнения)
> На этом этапе происходит динамическая инициализация и выделение ресурсов, таких как создание объектов в динамической памяти, открытие файлов и сетевых соединений. Этот процесс продолжается в течение всего времени выполнения программы. 
8. Shutdown (Этап завершения) 
> Когда программа завершает свое выполнение, она проходит через этап завершения, на котором освобождаются все выделенные ресурсы, закрываются открытые файлы и сетевые соединения, выполняются деструкторы глобальных объектов (в C++), и операционная система очищает память, выделенную для программы.


##  Память
- Статическая память
> Используется компоновщиком для размещения объектов и переменных, которые существуют на протяжении всего времени выполнения программы:
- Автоматическая память - STACK
> 
- Свободная память - HEAP

# Практика 2
## Агрегатные (составные) типы данных
- Массивы
- Структуры
- Объединения 
- Перечисления
- Типы указателе (+-)

```c
// Structure
struct Person {
    char name[50];
    int age;
    float height;  
};

int main() {
    struct Person p = {"John", 20, 1.8};
    printf("%s, %d, %.2f\n", p.name, p.age, p.height);
    return 0;
}
```

```c
// Union
union Data {
    int i;
    float f;
    char str[20];
};
```

```c
// Enumerations

enum Day {
    One, Two, Three
};
```

# Лекция 2
**Big Endian** - младшие разряды числа впереди (удобнее для компьютера)
**Little Endian** - младшие разряды в конце

**<mark style="background: #FFB86CA6;">GDB</mark> - отладка**

## Линковка (связывание)
Статическое и динамическое
### Статическое связывание
Библиотеки  `lib<name>.a` - архив
Динамические: `lib<name>.so`

Связывание - процесс сборки и объединения различных ...

Прототип функции
```c
int myMax(int, int);
```
Чтобы компилятор не ругался
Прототип лучше выносить в отдельный header

Свой header указывается в кавычках
```
#include "func.h" 
```

`#pragma once` - один раз подключение, чтобы два раза не включать загаловки

1. Препроцессинг `gcc -E` 
2. Трансляция `gcc -S` (код на ассемблере)
3. Ассемблирование `gcc -c(ar)` - переносимый объектный файл (но они не запускаются)
    Указали только прототипы функций
4. Связывание (Линковка) `gcc -static(ld)`
    Статическое связывание берёт архивы библиотек и подставляет код в программу
    При динамическом связывании необходимы динамические библиотеки, из которых подгружаются функции


# Практика 4

# Лекция 3
gcc - драйвер компилятора

## Указатели
Указатель хранит адрес памяти
Может быть указатель на:
- Стек
- Кучу
- Статик
- Функцию (сегмент кода)

Тип функции определён типом её возвращаемого объекта и типами аргументов
```C
int func(int a, int b)
```
Эта функция имеет тип:
```C
int(int, int)
```
Указатель будет объявляться следующим образом:
```C
int (*pf) (int, int)
```
Скобки `(*pf)` обязательно 
Указатель всегда 8 байт
```C
int func(int a, int b){
    // ...
}
// ...
int (*pf) (int, int);
pf = func;
// OR
pf = &func
// ...
int res = pf(a, b);
// OR
int res = (*pf)(a, b);
```
Мы не можем переделать указатель одного типа на функцию на другой тип.

### Для C++ про перегруженные функции
```C++
void func(int);
void func(unsigned int);
void func(char);

void (*pf)(unsigned int) = func; // Определяет по типу указателя нужный вариант перегруженной функции
```
## Передача функции в виде аргумента
```C
void printHello() {
    printf("Hello World");
}

void execute(void (*func)()) {
    func();
}

int main() {
    execute(printHello);
    return 0;
}
```

```C
#include <stdio.h>

void printHello(int a) {
    printf("Hello World, %d\n", a);
}

void execute(void (*func)(int), int a) {
    func(a);
}

int main() {
    int x = 1;
    execute(printHello, x);
    return 0;
}

```

# Практика 4
Узнать размер массив:
```C
int len_arr = sizeof(arr) / sizeof(arr[0])
```
Менять строку(указатель) не получится
```C
char *s = 'Hello';
s[0] = 'h'; // ERROR
```
Вот так можно:
```C
char s[] = 'Hello';
s[0] = 'h'; // It's okay
```
- `char str[] = "Hello"` - локальный массив
- `char *str = "Hello"` - readonly  
## Работа со строками
> Из библиотеки `string.h`
- `strcspn(str1, str2)` - Поиск вхождения `str1` в `str2` 
- `strcpy(str1, str2)` - Копирование `str1`
- `strncpy(str1, str2, n)` - Копирует `n` символов из строки `str1`, обязательно добавляем `\0` нуль-символ
- `strcmp(str1, str2)` - Сравнение двух строк (при `0` - равны, положительные или отрицательные значения)
- `strcat(str1, str2)` - Конкатенация (`str1` соединяется с `str2`, результат в `str1`)]
- `strcat(str1, str2, n)` - `str1` с `n` символами `str2`, результат в `str1`

# Лекция 4
![[Pasted image 20250303111200.png]]

## Создание библиотеки
Для создания статических библиотек используется программы `ar`  
Опции: 
- `r` - добавляет или заменяет 
- `c` - создаёт архив, если он ещё не существует
- `s` - добавляет индекс для ускорения поиска  

Статическая библиотека имеет суффикс `.a`  
### Подключение библиотеки
При компиляции (`gcc`):
- `-L` - указывает искать библиотеку в текущей директории
- `l<name>` - указывает на библиотеку `lib<name>.a`

## Динамическая библиотека(разделяемая библиотека)
![[Pasted image 20250303113143.png]]
`-shared` - указывает компилятору создать совместно используемую библиотеку и нужны специальные объектные файлы. 
![[Pasted image 20250303114141.png]]


# Практика 5

# Лекция 4
## Преобразование типов
Тип объекта определяет данные, которые он может содержать, и операции, которые с этим объектом можно совершать.  
Преобразование типов:
- Явно
- Неявно  

