_Валерия Алексеевна_  
CourseNeM0od1e,
# Лекция 1
**ООП** - парадигма программирования, в которой программа представляется как набор объектов, взаимодействующих друг с другом  
  
Основные принципы:
- **Наследование** - создание новых классов на основе существующих  
- **Полиморфизм** - использование объектов разных классов с одинаковым интерфейсом   
- **Инкапсуляция** - объединение данных и методов в одном объекте  
  
**Класс** - шаблон для создания объектов, определяет структуру и поведение объектов  
**Объект** - конкретная реализация класса  
  
# Лекция 2
## Системное программирование
**Системное программирование (СП)** —  это разработка ПО, которое тесно взаимодействует с аппаратной обеспечением и ОС, управляя ее ресурсами *(процессор, память, диски, сеть, устройства I/O)*.  
  
Разница между системным и прикладным программистом — прикладной решает задачи ежедневные  
  
**Примеры задач на python:**
- запуск и управление приложениями/программами
- создание параллельно выполняющихся частей кода (процессы, потоки)
- эффективная обработка тысяч сетевых подключений одновременно
- взаимодействие между разными программами 
- управление ресурсами и их синхронизация  
  
### Ключевые модули:
- **multiprocessing**: Создание и управление
процессами (обход GIL).
- **threading**: Работа с потоками выполнения.
- **asyncio**: Фреймворк для асинхронного
программирования.
- **subprocess**: Запуск внешних процессов.
- **os / sys**: Взаимодействие с окружением и
интерпретатором.
- **concurrent.futures**: Высокоуровневый
интерфейс для пулов потоков и процессов.
### Конкуретность
**Конкурентность** — кажущееся одновременное выполнение нескольких задач на одном ядре. Задачи начинают, выполняют и завершают перекрывающиеся периоды времени, но не обязательно в один и тот же момент
Цель: эффективно управлять задачи с вводом/выводом, не блокируя выполнение на время ожидания
Инструменты: потоки и асинхронности

### Асинхронность
**Асинхронность** — частный случай конкурентности, основанный на кооперативной многозадачности. Задача добровольно отдает управление, когда ей нужно ждать что-то. Пока одна задача ждет event loop,  event loop помогает запустить выполнение другой задачи
Ключевое отличие потоков: нет принудительного переключения планировщиков ОС. Переключение происходит только в точках AWAIT.
Взаимодействие с ОС: процессы, потоки, системные выводы

### Процесс
**Процесс** — экземпляр выполняемой программы, у каждого процесса есть свое собственное пространство памяти (изолированная память). Процессы создаются и управляются ОС, переключение между процессами — дорогая операция(multiprocessing, os в Python)

### Поток
**Поток(нить)** — легковесный «поток» выполнения внутри процесссов. Все потоки одного процесса делят одно адресное пространство, т.е. пространство в памяти (у них общая память). Переключение между потоками дешевле, чем между процессами (дешевле - проще, дороже - сложнее. В Python - модуль treading, управляется планировщиком ОС)
  
> Чем отличается процесс от потока — памятью

### System Call
**System Call** — интерфейс, через который программа запрашивает услугу у ядра ОС. 
Практически всё, что связано с I/O (файлs, сеть), создание процессов и тд - это системные вызовы.

# Учебная практика 1
# Лекция 3
## Синхронизация потоков в Python
### Lock-объект
> Представляет собой базовый механизм синхронизации потоков

Он может находиться только в двух состояниях:
- Захваченном (заблокированном)
- Свободным  
  
Для работы:
- `acquire()` - переводит в заблокированное состояние
- `release()` - освобождает блокировку  
  
Если поток пытается захватить уже заблокированный ресурс, то этот поток перейдёт в ожидание освобождение потока  

#### Параметры `acquire()`
- `blocking (bool)` - При True поток ожидает освобождения заблокированного Lock-объекта, при False поток не блокируется (не ожидает), а метод сразу возвращает False, если Lock-объекта заблокирован
- `timeout (float)` - максимальное время ожидание в секундах при попытке захватить занятый Lock-объект
- `locked()` - дополнительный метод для проверки состояния Lock-объекта

```python
lock_obj = Lock()

with lock_obj:
    # Работа с разделяемым ресурсом
```

### RLock - Рекурсивная блокировка
- В отличии от Lock освободить RLock может только тот поток, который его захватил
- Если возможность вложенные захватах, присутствует счётчик захватов
- Освобождает только после `release()`, вызванное столько же раз, сколько и кол-во захватов 
- Нет метода `locked()`

### Condition
Работают в парадигме Producer-Consumer (Производитель-Потребитель), где потоки должны ожидать готовности ресурса и получать уведомления о его доступности  
  
**Алгоритм:**
- Потребитель проверяет доступность ресурса, если недоступен вызывает `wait()`
- Производитель готовит ресурс
- Оповещает потребителей через `notify()` или `notify_all()`
- Разблокированный потребитель получает доступ к ресурсу

![[Pasted image 20251015113656.png]]
### Семафоры
Позволяют ограничить количество потоков, которые могут одновременно работать с определенным ресурсом.  
  
![[Pasted image 20251015121852.png]]
Важно понимать принципиальное отличие семафора от блокировки. Блокировка обеспечивает эксклюзивный доступ - только один поток может работать с ресурсом. Семафор позволяет работать нескольким потокам одновременно, но в ограниченном количестве.
### События - простые сигналы

События представляют собой простейший механизм оповещения между потоками.Оно может находиться в одном из двух состояний: **установленном или сброшенном**. Потоки могут ждать установки события, причем ожидание может быть с ограничением по времени.  
Когда событие устанавливается, все ожидающие его потоки одновременно продолжают работу. Это полезно для синхронизации начала работы нескольких потоков или для уведомления о наступлении определенного условия.

### Барьеры - синхронизация групп

Барьеры решают задачу синхронизации группы потоков в определенной точке выполнения. Барьер создается с указанием количества потоков, которые должны достичь точки синхронизации.  
  
Каждый поток, доходя до барьера, блокируется. Когда последний поток достигает барьера, все потоки одновременно разблокируются и продолжают работу.  

### Таймеры - отложенное выполнение

Таймеры позволяют отложить выполнение операции на определенное время. В отличие от простой паузы в выполнении, таймер создает отдельный поток, который ждет указанное время, а затем выполняет заданное действие.  
  
Таймер можно отменить до его срабатывания, что обеспечивает гибкость управления отложенными операциями.  
  
Таймеры полезны для реализации различных сценариев: отправки напоминаний, выполнения задач по расписанию, установки таймаутов на операции, организации периодического выполнения задач.

