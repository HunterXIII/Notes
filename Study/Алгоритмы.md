# Лекция 1. Вступление
__Алгоритм__ - это набор конечного числа правил, задающих последовательность выполнения операций компьютерной программой для решения задачи определённого типа.

__Алгоритмическое мышление__ 

Свойства алгоритмов:
- ___Конечность___ - алгоритм всегда должен заканчиваться после выполнения конечного числа шагов
- ___Определённость___ - действия, которые нужно выполнить должны быть строго и недвусмысленно определены для каждого возможного случая
- ___Ввод___ - алгоритм имеет некоторое (>=0) число входных данных
- ___Вывод___ - алгоритм должен иметь одно или несколько выходных данных
- ___Эффективность___ - Алгоритм обычно считается эффективным, если все его операторы достаточны просты и понятны

Алгоритм Евклида

## Память и время

_Четыре аспекта использовании памяти:_
Количество памяти, ...
- Необходимое для хранения кода алгоритма
- Необходимое для входных данных
- Необходимое для любых выходных данных (Некоторые алгоритмы, такие как сортировки, )
- Необходимое для вычислительного процесса во время вычислений

## "O" большое
> Математическое обозначение для сравнения асимптотического поведения функции


# Лекция 2. Числовые алгоритмы

# Лекция 3. Алгоритмы сортировки
__Алгоритм сортировки__ - алгоритм для упорядочивания элементов в списке
## Сортировка пузырьком O(n^2)
```python
def bubble_sort(arr):
	for _ in range(len(arr)-1):
		flag = True
		for j in range(len(arr)-i-1):
			if arr[j] > arr[j+1]:
				arr[j], arr[j+1] = arr[j+1], arr[j]
				flag = False
		if flag:
			break
	return arr

print(bubble_sort([3, 2, 1]))
```

## Сортировка вставками
```python
import random
arr = [random.randint(1, 100) for _ in range(random.randint(1, 10))]
print(arr)

def insert_sort(arr):
	for i in range(1, len(arr)):
		while arr[i] < arr[i-1] and i > 0:
			arr[i], arr[i-1] = arr[i-1], arr[i]
			i -= 1
	return arr

print(insert_sort(arr))
```
Можно улучшить, добавив бинарный поиск

## Метод "разделяй и властвуй"


# Лекция 4. Динамическое программирование
___Динамическое программирование(ДП)___ - способ решения сложных задач путём разбиения их на более простые.
- __ДП сверху__ - простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем
- __ДП снизу__ (табулация)- включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач. \

### Задача о рюкзаке
 > Дано: N предметов, каждый предмет имеет вес и стоимость. нужно выбрать все предметы, вес которых не превышает W, наибольшей стоимостью

# Лекция 5. Структуры данных
Элементарные структуры данных: булевый, указательный(содержит адрес памяти), числовой, символьный \
___Абстрактный тип данных (АТД)___ - некоторая математическая или информационная модель с совокупностью операторов, определённых в рамках этой модели \
__Линейный однонаправленный список__ - структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. \
__Односвязный список__ - ссылка в одну сторону \
__Двусвязный список__ - ссылка в обе стороны (На следующий и на предыдущий) \
__Стек (stack - стопка)__ - добавление и удаление элементов происходит с одного конца \
__Очереди__ - удаление первого элемента, добавление нового элемента происходит в конец \
__Дек (double ended queue)__ - удаление и добавление может происходить как с начала, так и с конца \
__Множество__ - классическое математическое множество, не имеет порядок и без повторений значений \
__Куча (heap)__ - это полное двоичное дерево, удовлетворяющее свойству кучи: если узел A - это родитель узла B, то ключ узла A больше либо равен ключу узла B:
- min-куча
- max-куча
```mermaid
graph TD;
	id1((1)) --> id2((2))
	id1((1)) --> id3((3))
	id2 --> id4((4))
	id2 --> id5((5))
	
```
`[1, 2, 3, 4, 5]`

# Лекция 6.  Графы
___Граф___ - математическая абстракция, объекты которой обладают парными связями
- Простой (неориентированный)
- Ориентированный граф
- Взвешенный граф
Путь - любая последовательность вершин \
Длина пути - количество рёбер \
### Способы хранения графов
- Матрица смежности
- Список смежности
- Матрица инцидентности
## Поиск в глубину
> Один из основных методов обхода графа 

#DFS
**Пошаговое представление:**
1. Выбираем любую вершину из еще не пройденных, обозначим ее как `   u   `.
2. Запускаем процедуру `   dfs(u)   `
     1. Помечаем вершину `   u   ` как пройденную
     2. Для каждой не пройденной смежной с `u` вершиной (назовем ее `v`) запускаем `dfs(v)`
3. Повторяем шаги 1 и 2, пока все вершины не окажутся пройденными.
### Выделение компонент связности
Для поиска компонент связности используется обычный DFS практически без модификаций. При запуске обхода из одной вершины, он гарантированно посетит все вершины, до которых возможно добраться, то есть, всю компоненту связности, к которой принадлежит начальная вершина. Для нахождения всех компонент просто попытаемся запустить обход из каждой вершины по очереди, если мы ещё не обошли её компоненту ранее. \
Простейший вариант: просто заполнить список `comp`, где `   comp[i]   ` - номер компоненты связности, к которой принадлежит вершина `i`.
## Алгоритм Кана и топологическая сортировка
> Поиск циклов или топологическая сортировка(для каждого ребра uv, вершина u раньше вершины v)

#Кана
**Пошаговое представление** \
1. Создаём список, где указываем для каждой вершины количество входящих рёбер 
2. Если количество входящих рёбер равно 0, добавить в очередь
3. Взять вершину из очереди и пометить как посещённую
4. Для всех смежных вершин уменьшить количество входящих рёбер на 1
5. Добавить в очередь вершину, если количество входящих рёбер равно 0
6. Пока очередь не пуста снова с шага 3 \
Список посещённых вершин (в том порядке, в котором их добавляли) будет результат топологической сортировки. Если количество рёбер в результате не равно общему количеству рёбер => в графе есть цикл, топологическая сортировка невозможна

# Лекция 7. Кратчайшие пути в графах
**Обход в ширину (Поиск в ширину, BFS, Breadth-first search)** — один из простейших алгоритмов обхода графа, являющийся основой для многих важных алгоритмов для работы с графами. \
## BFS
#BFS
1. Создадим массив $dist$ расстояний. Изначально $dist[s]=0$ (поскольку расстояний от вершины до самой себя равно $0$) и $dist[v]=∞$ для $v≠s$.
2. Создадим очередь $q$. Изначально в $q$ добавим вершину $s$.
3. Пока очередь $q$ не пуста, делаем следующее:
    1. Извлекаем вершину $v$ из очереди.
    2. Рассматриваем все рёбра $(v,u)∈E$, то есть те, которые выходят из вершины $v$ Для каждого такого ребра пытаемся сделать релаксацию: если $dist[v]+1<dist[u]$, то мы делаем присвоение $dist[u]=dist[v]+1$ и добавляем вершину $u$ в очередь.
### Волновой метод
### Принадлежит ли вершина кратчайшему пути
Запустим из вершины $s$ в графе $G$ BFS в вершину $v$ — найдём расстояния $d_1$. Построим транспонированный граф $G^T$ — граф, в котором каждое ребро заменено на противоположное. Запустим из вершины $t$ в графе $G^T$ BFS в вершину $v$ — найдём расстояния $d_2$. \
Теперь очевидно, что $v$ принадлежит хотя бы одному кратчайшему пути из $s$ в $t$ тогда и только тогда, когда $d_1(v)+d_2(v)=d_1(t)$ — это значит, что есть путь из $s$ в $v$ длины $d_1(v)$, а затем есть путь из $v$ в $t$ длины $d_2(v)$, и их суммарная длина совпадает с длиной кратчайшего пути из $s$ в $t$.
## Алгоритм Дейкстры 
> Данный алгоритм находит кратчайший путь во взвешенных графах (!!! без отрицательного веса)

#Дейкстры
1. Создать массив $dist$ расстояний. Изначально $dist[s]=0$ и $dist[v]=∞$ для $v≠s$.
2. Создать булев массив $used$, $used[v]=0$ для всех вершин $v$ — в нём мы будем отмечать, совершалась ли релаксация из вершины.
3. Пока существует вершина $v$ такая, что $used[v]=0$ и $dist[v]≠∞$, притом, если таких вершин несколько, то $v$ — вершина с минимальным $dist[v]$, делать следующее:
    1. Пометить, что мы совершали релаксацию из вершины $v$, то есть присвоить $used[v]=1$.
    2. Рассматриваем все рёбра $(v,u)∈E$. Для каждого ребра пытаемся сделать релаксацию: если $dist[v]+w(v,u)<dist[u]$, присвоить $dist[u]=dist[v]+w(v,u)$.


# Лекция 8. Кратчайшие пути в ациклических ориентированных графах
## Алгоритм Беллмана-Форда
>Ищет кратчайший путь в ориентированных взвешенных графах, в случае обнаружения цикла отрицательного веса сообщает об этом

#Беллмана-Форда
1. Инициализация: всем вершинам присваивается предполагаемое расстояние $dist[v]=∞$, кроме вершины-источника, для которой $dist(u)=0$.
2. Релаксация множества рёбер $E$
    1. Для каждого ребра $e=(v,z)∈E$ вычисляется новое предполагаемое расстояние $new_dist(z)=dist(v)+w(e)$.
    2. Если $new_dist(z)<dist(z)$, то происходит присваивание $dist(z)=new_dist(z)$ (релаксация ребра $e$).
3. Алгоритм производит релаксацию всех рёбер графа до тех пор, пока на очередной итерации происходит релаксация хотя бы одного ребра.
4. **Критерий наличия достижимого цикла отрицательного веса**: если после $n-1$ фазы мы выполним ещё одну фазу, и на ней произойдёт хотя бы одна релаксация, то граф содержит цикл отрицательного веса, достижимый из $v$; в противном случае, такого цикла нет.

## Алгоритм Флойда
> Алгоритм нахождения длин кратчайших путей между всеми парами вершин во взвешенном ориентированном графе.

#Флойда
Обозначим длину кратчайшего пути между вершинами $u$ и $v$, содержащего, помимо $u$ и $v$, только вершины из множества ${1..i}$ как $d^{(i)}_{uv}$, $d^{(0)}_{uv}=ω_{uv}$.

На каждом шаге алгоритма, мы будем брать очередную вершину (пусть её номер — $i$) и для всех пар вершин $u$ и $v$ вычислять $d^{(i)}_{uv}=\min{(d^{(i−1)}_{uv},d^{(i−1)}_{ui}+d^{(i−1)}_{iv})}$. То есть, если кратчайший путь из $u$ в $v$, содержащий только вершины из множества ${1..i}$, проходит через вершину $i$, то кратчайшим путем из $u$ в $v$ является кратчайший путь из $u$ в $i$, объединенный с кратчайшим путем из $i$ в $v$. В противном случае, когда этот путь не содержит вершины $i$, кратчайший путь из $u$ в $v$, содержащий только вершины из множества ${1..i}$ является кратчайшим путем из $u$ в $v$, содержащим только вершины из множества ${1..i−1}$.
# Лекция 9. Минимальное покрывающее дерево
**Остовное(покрывающее) дерево** \
# Лекция 10.  Транспортные сети.  Максимальный поток. Алгоритм Форда-Фалкерсона

