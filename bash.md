# Bash
> Командная оболочка, написанная на C; скриптовый, интерпретируемый язык

## Запуск файла
__Sha-Bang строка:__\
`#!/bin/bash` путь к используемому интерпретатору.\
`chmod +x name_file.sh` - Дать файлу скрипта права на запуск\
`chmod +(добавить права) -(забрать права)`
* `r` - read - права на чтение
* `w` - write - права на запись
* `x` - execute - права на запуск\\
`./name_file.sh` | `bash name_file.sh` - запуск bash-скрипта

### Оформление кода
```
#комментарий
- #TODO - сделать что-то
- #NOTE - заметка
```
    Отступы для красоты
---

## Переменные 
Переименованный адрес к памяти\
`a=10`- объявление\
`$a`  - обращение к переменной

## Математические операции 
- в круглых скобках
- результат с помощью $ 
`a=$(($a+1))`

---

### Вывод
`echo текст`\
`echo "текст с переменной $var"`\
`echo TEXT > file` - перенаправленный поток вывода
### Ввод
`read var`\
`read -p "TEXT" var`

---

#### Выполнение команд
`result=$(cat file.txt)` - выполние команды и запись результата в переменную\
```result=`cat file.txt` ``` - второй вариант, косые ковычки!

---

## Ветвление
```
if [[ условие ]]
then
    # код, если True
else
    # код, если False
fi
```

### Логические операции
Вместо **<,>,==** используются:
- `-gt` (greater than - больше, чем)
- `-ge` (greater equal - больше или равно)
- `-lt` (lower than - меньше, чем)
- `-le` (lower equal - меньше или равно)
- `-eq` (equal - равно)
- `-ne` (not equal - не равно)
- `-a` (and)
- `-o` (or)
---
## Циклы
### Цикл *for*
> Первый вариант
```
for student in Ivan Petr Vasya
do
    echo "$student"
done
```
> Второй вариант
```
for student in $(cat students) #В файле обязательно пустую строчку в конце
do
    echo "$student"
done
```
> Третий вариант (как в C)
```
for ((i=0; i<5; i++))
do
    echo $i
done
```
### Цикл *while*
> Первый вариант
```
i=0
while [$i -lt 5]
do
    echo $i
    i=$(($i+1))
done
```
> Второй вариант
```
while read student #В файле обязательно пустую строчку в конце
do
   echo $student
done < students
```
## Циклы *switch case*
> Осуществляет сопоставление текущего значения переменной заданным вариантам, выполняя соответсвующий им код
```
case var in
    value_1) #код ;;
    value_2) #код ;;
    value_3) #код ;;
    *) #код, если предыдущие варианты не подошли ;;
esac
```
---
## Приём аргументов (параметров)
- `$0` - имя скрипта
- `$1` - первый аргумент
- `$2` - второй аргумент - и так далее, вплоть до переменной `$9`\
Параметры командной строки разделяются пробелами\
Если нужно обратиться к параметру, индекс которого состоит больше, чем из одной цифры, надо ииспользовать фигурные скобки: `${10}`, `${11}` и т.д.
### Особые конструкции работы с параметрами
- `$#` - Количество параметров
- `$*` - Все параметры (вместе)
- `$@` - Все параметры (по отдельности)
- `${!#}` - Последний параметр
### Ключевое слово *shift*
Сдвигает значение позиционных параметров влево.
> Например, значение переменной `$3` становится значение переменной `$2`, значение `$2` переходит `$1`, а то, что было до этого в `$1` теряется.\
> Пример, на нахождение параметра
```
while [[ -n "$1" ]]
do
    case "$1" in
        -a) echo "Найден параметр -a" ;;
        -b) echo "Найден параметр -b" ;;
        -c) echo "Найден параметр -c" ;;
        *) echo "$1 не параметр" ;;
    esac
    shift
done
```
---
## Потоки вывода и ввода
- 0, STDIN - стандартный поток ввода
- 1, STDOUT - стандартный поток вывода
- 2, STDERR - стандартный поток ошибок
  
Поток можно перенаправить исполюзуя его номер, к примеру, `2>ls_errors`\
Временной перенапрвление:
> - Присоединяя к содержимому файла командой `>>`
> `echo "This is error" >> list_of_errors`
> - Перезаписывая файл комадой `>`
>`echo "This is error" > list_of_errors`

Постоянное перенаправление командой `exec`
> К примеру
```
exec 1>outfile
echo "Test output"
```
