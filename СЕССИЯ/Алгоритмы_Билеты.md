# 1. Алгоритм. Память и время как ресурсы.

## Алгоритм
**Алгоритм** - это набор шагов или инструкций, необходимых для решения задачи
ИЛИ
**Алгоритм** - это набор конечного числа правил, задающих последовательность выполнения операций компьютерной программой для решения задачи определённого типа

**Свойства алгоритма:**
- **Конечность.** Алгоритм всегда должен заканчиваться после выполнения конечного числа шагов.
- **Определённость.** Действия, которые нужно выполнить, должны быть строго и недвусмысленно определены для каждого возможного случая.
- **Вввод.** Алгоритм имеет некоторое (возможно, равное нулю) число входных данных.
- **Вывод.** У алгоритма есть одно или несколько выходных данных , т. е. величин, имеющих вполне определенную связь с входными данными.
- **Эффективность.** Алгоритм обычно считается эффективным, если все его операторы достаточно просты для того, чтобы их можно было точно выполнить в течение конечного промежутка времени с помощью карандаша и бумаги.

## Память
Для анализа алгоритма обычно используется анализ пространственной сложности алгоритма, чтобы оценить необходимую память времени исполнения как функцию от размера входа. Результат обычно выражается в терминах **«O» большое**.

Существует **четыре аспекта использования памяти**:
- Количество памяти, необходимой для **хранения кода алгоритма.**
- Количество памяти, необходимое для **входных данных**.
- Количество памяти, необходимое **для любых выходных данных** (некоторые алгоритмы, такие как сортировки, часто переставляют входные данные и не требуют дополнительной памяти для выходных данных).
- Количество памяти, необходимое **для вычислительного процесса** во время вычислений (сюда входят именованные переменные и любое стековое пространство, необходимое для вызова подпрограмм, которое может быть существенным при использовании рекурсии).

## Время
Для анализа алгоритма обычно используется анализ временной сложности алгоритма, чтобы оценить время работы как функцию от размера входных данных. Результат обычно выражается в терминах «O» большое
> Не выражается в секундах, минутах или часах, так как эти величины зависят от мощности железа, на котором запускается алгоритм. Поэтому время считают в количестве **итераций (операций)**.  

--- 
# 2. O-символика как инструмент оценки ресурсов, различные асимптотики (логарифм, полином, экспонента).

**"О" большое** - Это математическое обозначение для сравнения асимптотического поведения (асимптотики) функций. Используются в различных разделах математики, но активнее всего — в математическом анализе, теории чисел и комбинаторике, а также в информатике и теории алгоритмов. Под асимптотикой понимается характер изменения функции при стремлении её аргумента к определённой точке.

Запись $О(f(n))$ означает, что с увеличением параметра, характеризующего количество входной информации алгоритма, время работы алгоритма будет возрастать не быстрее, чем $f(n)$, умноженная на некоторую константу.

$f(n) = O(1)$ константа
$f(n) = O(log(n))$ логарифмический рост
$f(n) = O(n)$ линейный рост
$f(n) = O(n*log(n))$ квазилинейный рост
$f(n) = O(n^m)$ полиномиальный рост
$f(n) = O(2^n)$ экспоненциальный рост - самый худший
$f(n) = O(n!)$ сначала нормально, потом резко растет 


![[Pasted image 20250102124646.png]]
![[Pasted image 20250102124738.png]]
![[Pasted image 20250102124804.png]]
![[Pasted image 20250102124818.png]]
![[Pasted image 20250102124827.png]]

---
# 3. Метод математической индукции, использование для доказательства оценок

**Математическая индукция** - если утверждение истинно в одном случае, то оно окажется истинным и в следующем за ним случае.

**Математическая индукция** — это метод доказательства, который состоит из двух основных шагов:
1. **База индукции**: Необходимо показать, что утверждение $P(1)$ верно.
2. **Шаг индукции**: Нужно доказать, что если утверждение верно для некоторых целых положительных чисел $P(1),P(2),…,P(n)$, то оно также верно для следующего числа $P(n+1)$. Это доказательство должно быть справедливо для любого целого положительного n.

> P.S. *Не очень понятно, что конкретно нужно*

---
# 4. Алгоритмы для работы с большими числами: сложение, умножение, быстрое возведение в степень

**Необходимость использования:**
- Ограничения на объем типов данных
- Время выполнения операций на больших числах
- Использование встроенных функций ограниченно типами данных и особенностями реализации
## Сложение
1. Числа представлены в виде массивов, состоящих из "коротких" чисел (играют роль цифр) 
2. Массив для результата и переменная для переноса (изначально 0) 
3. Складываются разряды двух чисел с учётом переноса перенос
4. Если после сложения всех разрядов остался перенос, он добавляется вперёд числа (к старшему разряду)
## Умножение большого числа на малое 
Аналогично сложению, только вместо сложения разрядов(шаг 3) происходит перемножение, и также учитывается сложение с переносом. 
## Умножение большого числа на большое
Состоит из умножения на малое число и сложения. 
1. Одно число умножается на каждый разряд другого (умножение большого числа на малое)
2. Промежуточные результаты складывается (учитывая "положения числа", т. е. 25 * 25 это 125 + 50***0***) 
## Быстрое возведение в степень
1. Если степень n чётная, основание возводится в квадрат, а степень делится на 2.
2. Если степень n нечётная, основание умножается на результат, а степень уменьшается на 1.
3. Процесс повторяется до тех пор, пока k>0.

---
# 5. Арифметика по модулю: сложение, умножение, возведение в степень

Если два целых числа a и b при делении на m дают одинаковые остатки, то они называются **сравнимыми (или равноостаточными) по модулю числа m. a ≡ b (mod m)**
сравнимыми (или равноостаточными) по модулю числа m. a ≡ b (mod m)

**Операции по модулю:**
(A + B) mod C = (A mod C + B mod C) mod C 
(A * B) mod C = (A mod C * B mod C) mod C 
A^B mod C = ( (A mod C)^B ) mod C

--- 
# 6. Алгоритм Евклида, расширенный алгоритм Евклида.

**Алгоритм Евклида** - находит **наибольший общий делитель** для чисел m и n
1. Разделим $m$ на $n$, и пусть остаток от деления будет равен $r$ (где $0 ≤ r < n$).
2. Если $r = 0$, то выполнение алгоритма прекращается; $n$ — искомое значение.
3. Присвоить $m = n, n = r$ и вернуться к шагу 1.
```python
def euclidus(m, n):
    while n:
        m, n = n, m % n
    return m
```

**Расширенный алгоритм Евклида** 
В то время как "обычный" алгоритм Евклида просто находит наибольший общий делитель двух чисел m и n, расширенный алгоритм Евклида находит помимо НОД также коэффициенты x и y такие, что:
$$ x * m + y * n = НОД(m, n) $$
Т.е. он находит коэффициенты, с помощью которых НОД двух чисел выражается через сами эти числа.

```python
def extended_euclidus(m, n):
    if n == 0:
        return m, 1, 0
    d, x1, y1 = extended_euclidus(n, m % n)
    x = y1
    y = x1 - (m // n) * y1
    return d, x, y
```
